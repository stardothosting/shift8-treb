{
    "ignoreLinterErrors": [
        "Undefined function add_action",
        "Undefined function add_filter",
        "Undefined function add_menu_page",
        "Undefined function add_submenu_page",
        "Undefined function wp_verify_nonce",
        "Undefined function wp_send_json_success",
        "Undefined function wp_send_json_error",
        "Undefined function wp_localize_script",
        "Undefined function wp_enqueue_script",
        "Undefined function wp_enqueue_style",
        "Undefined function wp_add_inline_style",
        "Undefined function esc_html__",
        "Undefined function esc_html",
        "Undefined function esc_attr",
        "Undefined function current_user_can",
        "Undefined function get_option",
        "Undefined function update_option",
        "Undefined function add_option",
        "Undefined function plugin_dir_path",
        "Undefined function plugin_dir_url",
        "Undefined function plugin_basename",
        "Undefined function load_plugin_textdomain",
        "Undefined function register_activation_hook",
        "Undefined function register_deactivation_hook",
        "Undefined function is_plugin_active",
        "Undefined function admin_url",
        "Undefined function wp_create_nonce",
        "Undefined function current_time",
        "Undefined function wp_clear_scheduled_hook",
        "Undefined function wp_schedule_event",
        "Undefined function wp_next_scheduled",
        "Undefined function wp_remote_get",
        "Undefined function wp_remote_request",
        "Undefined function wp_remote_retrieve_response_code",
        "Undefined function wp_remote_retrieve_body",
        "Undefined function wp_insert_post",
        "Undefined function wp_update_post",
        "Undefined function get_posts",
        "Undefined function wp_upload_dir",
        "Undefined function wp_mkdir_p",
        "Undefined function wp_delete_file",
        "Undefined function wp_json_encode",
        "Undefined function sanitize_text_field",
        "Undefined function sanitize_email",
        "Undefined function esc_url_raw",
        "Undefined function wp_unslash",
        "Undefined function wp_die",
        "Undefined function check_admin_referer",
        "Undefined function add_settings_error",
        "Undefined function register_setting",
        "Undefined function wp_salt",
        "Undefined function wp_filesystem",
        "Undefined constant WP_DEBUG",
        "Undefined constant WP_DEBUG_LOG",
        "Undefined constant ABSPATH",
        "Undefined constant HOUR_IN_SECONDS",
        "Undefined constant DAY_IN_SECONDS"
    ],
    "context": "WordPress plugin development - WordPress core functions and constants are always available",
    "versionManagement": {
        "description": "Automatically update CSS/JS version references when files are modified",
        "trigger": "When modifying WordPress plugin CSS or JS files",
        "actions": [
            "Check for wp_enqueue_style() and wp_enqueue_script() calls that reference the modified file",
            "Update the version parameter to use the plugin's version constant (e.g., SHIFT8_TREB_VERSION)",
            "Replace hardcoded version numbers like '1.0.0' with centralized constants",
            "For development, consider using PLUGIN_VERSION . '-' . time() for immediate cache busting",
            "For production, use just the plugin version constant"
        ],
        "examples": {
            "before": "wp_enqueue_script('admin-js', $url, array(), '1.0.0', true);",
            "after": "wp_enqueue_script('admin-js', $url, array(), SHIFT8_TREB_VERSION, true);",
            "development": "wp_enqueue_script('admin-js', $url, array(), SHIFT8_TREB_VERSION . '-' . time(), true);"
        }
    },
    "trebSpecificRules": {
        "description": "TREB/AMPRE API specific development guidelines",
        "apiIntegration": {
            "baseUrl": "https://query.ampre.ca/odata/",
            "authentication": "Bearer JWT token in Authorization header",
            "rateLimiting": "Implement proper rate limiting and caching to avoid API abuse",
            "errorHandling": "Always handle API errors gracefully with proper logging",
            "dataValidation": "Validate all API responses before processing"
        },
        "cronScheduling": {
            "rule": "Use WordPress wp-cron system instead of system cron",
            "frequency": "Default to hourly sync, allow admin configuration",
            "errorRecovery": "Implement retry logic for failed API calls",
            "logging": "Log all sync activities for debugging"
        },
        "postManagement": {
            "rule": "Create regular WordPress posts (NOT custom post types) exactly like Python script",
            "duplicateHandling": "Use MLS number as post tag to prevent duplicates",
            "imageHandling": "Download images to wp-content/uploads/treb/{mlsnumber}/ and set featured image",
            "postStructure": "Title: full address, Content: from template, Excerpt: formatted address/price/MLS",
            "categories": "Use 'Listings' for own agent, 'OtherListings' for others",
            "tags": "Use MLS number as post tag for duplicate detection"
        },
        "dataMapping": {
            "rule": "Map AMPRE API fields to WordPress post structure",
            "requiredFields": ["ListingKey", "UnparsedAddress", "ListPrice", "ContractStatus", "ListAgentKey", "ModificationTimestamp"],
            "customFields": "Store all additional listing data as custom fields",
            "taxonomies": "Use WordPress taxonomies for property types, locations, etc.",
            "keyFields": {
                "ContractStatus": "Use 'Available' for active listings (not StandardStatus)",
                "ModificationTimestamp": "Critical for incremental sync and listing age filtering",
                "ListAgentKey": "Essential for member-based categorization"
            }
        },
        "queryOptimization": {
            "rule": "Follow AMPRE API documentation patterns exactly",
            "filterStructure": "Use ContractStatus eq 'Available' and ModificationTimestamp ge [ISO8601]",
            "ordering": "Always use $orderby=ModificationTimestamp,ListingKey for consistent results",
            "incrementalSync": "Implement ModificationTimestamp-based incremental sync to reduce API load",
            "listingAge": "Support listing age filters (days) that convert to ModificationTimestamp cutoffs",
            "avoidExpansion": "Do NOT use $expand=Media - it's not supported and causes 400 errors"
        }
    },
    "wordpressPluginDirectoryCompliance": {
        "description": "Ensure all code meets WordPress.org plugin directory automated checker requirements",
        "inlineCssJsProhibition": {
            "rule": "ABSOLUTELY NO inline CSS or JavaScript allowed in plugin files",
            "rationale": "WordPress.org automated checker flags all inline <style> and <script> tags as violations",
            "enforcement": "Use wp_enqueue_style() and wp_enqueue_script() with wp_add_inline_script() for dynamic content",
            "violations": {
                "inlineStyles": "Any <style> tags in PHP files, admin pages, or templates",
                "inlineScripts": "Any <script> tags in PHP files, admin pages, or templates",
                "dynamicCss": "CSS generated in PHP strings or echoed directly"
            },
            "solutions": {
                "adminStyles": "Move all admin CSS to admin/css/admin.css and enqueue properly",
                "frontendStyles": "Create public/css/frontend.css for frontend styles",
                "dynamicJs": "Use wp_add_inline_script() with properly enqueued base script",
                "conditionalEnqueue": "Only enqueue on relevant pages (is_single(), admin pages, etc.)"
            },
            "examples": {
                "wrong": "<style>.my-class { color: red; }</style>",
                "correct": "wp_enqueue_style('my-plugin-style', $url, array(), VERSION);"
            }
        },
        "externalServicesDocumentation": {
            "rule": "ALL external API calls must be documented in readme.txt with comprehensive details",
            "requiredSection": "== External Services == section in readme.txt",
            "requiredDetails": [
                "Service name and purpose",
                "What data is sent and when",
                "Service provider information",
                "Links to terms of service",
                "Links to privacy policy",
                "User control and configuration options"
            ],
            "format": "**Service Name** with bullet points for each detail",
            "examples": {
                "apiService": "**AMPRE API (Toronto Real Estate Board)** - Purpose, data sent, when used, provider, terms, privacy",
                "geocoding": "**OpenStreetMap Nominatim API** - Purpose, data sent, when used, provider, usage policy, privacy"
            }
        },
        "contributorsCompliance": {
            "rule": "Contributors field must match actual WordPress.org usernames",
            "validation": "Verify each contributor username exists on WordPress.org",
            "format": "Contributors: username1, username2 (case-sensitive, comma-separated)",
            "common_mistake": "Using company names or display names instead of actual usernames"
        },
        "prefixConsistency": {
            "rule": "ALL plugin elements must use consistent, unique prefixes (minimum 4 characters)",
            "elements": [
                "Function names",
                "Class names", 
                "Constants",
                "Options and transients",
                "Database tables",
                "CSS classes",
                "JavaScript variables",
                "AJAX actions"
            ],
            "prefix": "shift8_treb_ for this plugin",
            "validation": "Automated checker scans for generic names and prefix violations"
        },
        "securityRequirements": {
            "outputEscaping": {
                "rule": "ALL output must be escaped using appropriate WordPress functions",
                "functions": ["esc_html()", "esc_attr()", "esc_url()", "esc_js()", "wp_kses()"],
                "examples": {
                    "exceptions": "throw new Exception('Error: ' . esc_html($message));",
                    "variables": "echo esc_html($variable);",
                    "attributes": "<input value=\"<?php echo esc_attr($value); ?>\" />",
                    "urls": "<a href=\"<?php echo esc_url($link); ?>\">Link</a>"
                },
                "critical": "Exception messages MUST be escaped even if they seem safe"
            },
            "inputSanitization": {
                "rule": "ALL $_POST, $_GET, $_REQUEST input must be sanitized at point of access",
                "pattern": "isset($_POST['field']) ? sanitize_function(wp_unslash($_POST['field'])) : ''",
                "functions": ["sanitize_text_field()", "sanitize_email()", "sanitize_user()", "esc_url_raw()"],
                "examples": {
                    "text": "isset($_POST['text']) ? sanitize_text_field(wp_unslash($_POST['text'])) : ''",
                    "email": "isset($_POST['email']) ? sanitize_email(wp_unslash($_POST['email'])) : ''",
                    "url": "isset($_POST['url']) ? esc_url_raw(wp_unslash($_POST['url'])) : ''"
                },
                "critical": "ALWAYS use wp_unslash() before sanitization, and isset() checks are mandatory"
            },
            "nonceVerification": {
                "rule": "All form submissions must verify nonces BEFORE processing data",
                "pattern": "wp_verify_nonce(sanitize_text_field(wp_unslash($_POST['nonce'])), 'action_name')",
                "critical": "Nonce verification must happen first, and nonce itself must be sanitized"
            },
            "fileOperations": {
                "rule": "Use WordPress file functions instead of direct PHP file operations",
                "replacements": {
                    "unlink()": "wp_delete_file()",
                    "file_get_contents()": "$wp_filesystem->get_contents()",
                    "file_put_contents()": "$wp_filesystem->put_contents()",
                    "fopen/fwrite/fclose": "WP_Filesystem API"
                },
                "setup": "Always initialize WP_Filesystem before use"
            }
        },
        "developmentFunctions": {
            "rule": "Remove or conditionally wrap development functions for production",
            "functions": ["error_log()", "print_r()", "var_dump()", "var_export()"],
            "solutions": {
                "removal": "Delete development functions entirely",
                "conditional": "Wrap in if (defined('WP_DEBUG') && WP_DEBUG) { ... }",
                "replacement": "Use wp_json_encode() for logging instead of print_r()"
            },
            "examples": {
                "before": "error_log('Debug message');",
                "after": "if (defined('WP_DEBUG') && WP_DEBUG) { error_log('Debug message'); }"
            }
        },
        "fileStructure": {
            "rule": "Maintain proper WordPress plugin directory structure",
            "requirements": {
                "hiddenFiles": "NO hidden files (starting with .) allowed",
                "languagesDirectory": "Must exist and contain non-hidden placeholder file",
                "domainPath": "Header must point to existing directory",
                "textDomain": "Must match plugin folder name or be explicitly approved"
            },
            "solutions": {
                "languagesDirPlaceholder": "Create languages/readme.txt instead of .gitkeep",
                "removeHiddenFiles": "Delete .gitignore, .gitkeep, .DS_Store, etc."
            }
        },
        "headers": {
            "rule": "Plugin headers must be valid and point to existing resources",
            "required": ["Plugin Name", "Description", "Version", "Author"],
            "optional": ["Plugin URI", "Author URI", "Text Domain", "Domain Path", "Requires at least", "Tested up to"],
            "validation": {
                "domainPath": "Must point to existing directory",
                "textDomain": "Must be consistent throughout all files",
                "network": "Remove 'Network: false' - only use 'Network: true' if actually supports multisite"
            }
        },
        "textDomain": {
            "rule": "Text domain must be consistent across all files and match expectations",
            "pattern": "Prefer plugin folder name, but be consistent",
            "functions": ["__(), _e(), esc_html__(), esc_attr__(), _n(), _x()"],
            "validation": "All translation function calls must use the same text domain"
        }
    },
    "automatedChecks": {
        "description": "Run these checks before any plugin submission",
        "checklist": [
            "✓ All Exception messages wrapped in esc_html()",
            "✓ All $_POST/$_GET input sanitized with isset() and wp_unslash()",
            "✓ All nonce verification uses sanitized input",
            "✓ No direct file operations (use WP_Filesystem)",
            "✓ No development functions (error_log, print_r, var_dump)",
            "✓ No hidden files (.gitignore, .gitkeep, .DS_Store)",
            "✓ Languages directory exists with non-hidden placeholder",
            "✓ Text domain consistent across all files",
            "✓ Plugin headers point to existing resources",
            "✓ All output properly escaped",
            "✓ Version numbers updated in constants and headers",
            "✓ AMPRE API calls properly rate limited and cached",
            "✓ WordPress cron events properly scheduled and cleaned up",
            "✓ No duplicate function declarations",
            "✓ Run 'php -l' syntax check on all PHP files",
            "✓ Run 'wp eval' test after major changes",
            "✓ Test API queries with curl before implementing in code",
            "✓ Verify incremental sync works with ModificationTimestamp",
            "✓ Confirm member-based categorization creates correct categories",
            "✓ Test both web dashboard and WP-CLI sync functionality",
            "✓ Validate settings migration when schema changes",
            "✓ Verify template placeholders are properly replaced in post content",
            "✓ Test activation/deactivation cron scheduling and cleanup",
            "✓ Check actual post content with wp-cli to verify placeholder replacement",
            "✓ Ensure shortcodes are preserved (not processed) during post creation",
            "✓ Test address parsing for street number, name, and unit extraction",
            "✓ Verify dynamic content (virtual tours, WalkScore) only shows when data available",
            "✓ Test plugin works with multiple page builders (Visual Composer, Elementor, etc.)",
            "✓ Run security audit: grep for unescaped wp_create_nonce() calls",
            "✓ Run security audit: grep for unescaped exception messages",
            "✓ Run dead code audit: identify and remove unused functions/methods",
            "✓ Run duplication audit: identify and consolidate duplicate code",
            "✓ Verify all JavaScript output uses esc_js() for nonces and dynamic content",
            "✓ Check for duplicate settings registration between main and admin classes",
            "✓ Verify consistent bearer token handling across all components",
            "✓ Ensure all tests pass with zero tolerance for failures (composer test)",
            "✓ Verify no wrapper functions that just call other functions exist",
            "✓ Check for scattered authentication/encryption logic that should be centralized",
            "✓ Verify update and create paths have identical processing logic (especially image processing)",
            "✓ Check for orphaned attachments and implement auto-correction logic",
            "✓ Ensure batch processing validates actual processing vs skipping items",
            "✓ Verify all sync methods (CLI, Cron, Web) use shared service classes",
            "✓ Test comprehensive meta field storage (70+ fields) with proper sanitization",
            "✓ Validate attachment post_parent relationships are correct",
            "✓ Ensure silent failures have comprehensive debugging output",
            "✓ Verify featured image priority logic works correctly",
            "✓ Test existing attachment detection and orphaned attachment correction",
            "✓ Confirm HTTP request debugging provides actionable error information",
            "✓ CRITICAL: Verify NO temporary test files (test-*.php, debug-*.php) exist in plugin root",
            "✓ MANDATORY: Clean plugin root directory of any temporary/debug files before commits",
            "✓ CRITICAL: Verify composer test exits with code 0, not just passing tests",
            "✓ Ensure phpunit.xml excludes svn/ directory from code coverage",
            "✓ Check for 'Cannot declare class' errors during coverage generation",
            "✓ Verify conditional publishing logic (draft when no images, publish when images exist)",
            "✓ Test image retry logic on subsequent syncs",
            "✓ Verify auto-publish functionality when images become available"
        ]
    },
    "emergencyFixes": {
        "description": "Quick fixes for common WordPress.org plugin checker failures",
        "commands": {
            "escapeExceptions": "Find all 'throw new Exception' and wrap messages in esc_html()",
            "sanitizeInput": "Find all $_POST/$_GET and add isset(), wp_unslash(), sanitize_text_field()",
            "conditionalDebug": "Wrap error_log() in if (defined('WP_DEBUG') && WP_DEBUG)",
            "removeHidden": "Delete all files starting with . (dot)",
            "createLanguagesPlaceholder": "Create languages/readme.txt if languages/.gitkeep exists",
            "escapeJavaScriptNonces": "Find wp_create_nonce() in JavaScript and wrap with esc_js()",
            "removeWrapperFunctions": "Find and remove simple wrapper functions that just call other functions",
            "consolidateDuplicateSettings": "Identify duplicate settings registration and consolidate",
            "removeDeadCode": "Use grep to find unused functions and remove them systematically",
            "centralizeTokenHandling": "Move scattered bearer token logic into centralized service",
            "fixUpdatePathProcessing": "Ensure update_listing_post() calls same processing methods as create_listing_post()",
            "addOrphanedAttachmentCorrection": "Add post_parent validation and auto-correction in batch processing",
            "addBatchProcessingDebugging": "Add comprehensive CLI output and logging for batch operations",
            "validateSyncConsistency": "Verify all sync entry points use shared Sync_Service class",
            "addMetaFieldStorage": "Implement comprehensive meta field storage with proper sanitization",
            "cleanupTestFiles": "IMMEDIATELY delete any test-*.php, debug-*.php, or temporary files from plugin root",
            "fixPhpunitCoverage": "Add <directory>svn</directory> to <exclude> section in phpunit.xml to fix 'Cannot declare class' errors"
        }
    },
    "testFileCleanupPolicy": {
        "description": "CRITICAL: NEVER leave temporary test files in plugin root directory",
        "rule": "ABSOLUTELY FORBIDDEN to leave any temporary test files in the plugin root directory",
        "enforcement": "IMMEDIATELY delete any files matching these patterns from plugin root:",
        "forbiddenPatterns": [
            "test-*.php",
            "debug-*.php", 
            "temp-*.php",
            "scratch-*.php",
            "analyze-*.php",
            "check-*.php",
            "verify-*.php",
            "validate-*.php"
        ],
        "allowedTestLocations": [
            "tests/ directory ONLY",
            "tests/unit/ for unit tests",
            "tests/integration/ for integration tests",
            "tests/fixtures/ for test data"
        ],
        "mandatoryCleanup": {
            "rule": "ALWAYS clean up temporary files immediately after use",
            "process": [
                "1. Create temporary test files ONLY when absolutely necessary",
                "2. Use them for immediate testing/debugging",
                "3. DELETE them immediately after use - NO EXCEPTIONS",
                "4. NEVER commit temporary test files to git",
                "5. NEVER leave them in the plugin root directory"
            ]
        },
        "consequences": "Leaving test files in plugin root clutters the directory and violates clean code practices"
    },
    "developmentBestPractices": {
        "description": "Critical development practices learned from building this plugin",
        "settingsAPI": {
            "rule": "Always use WordPress Settings API properly",
            "formStructure": "Form action='options.php', settings_fields(), do_settings_sections()",
            "fieldNames": "Use 'plugin_settings[field_name]' format for all input names",
            "saveButton": "Use submit_button() function inside form element",
            "successMessage": "Add add_settings_error() in sanitize callback for confirmation",
            "defaults": "Set proper default values to prevent validation errors"
        },
        "ajaxSecurity": {
            "rule": "AJAX nonce consistency is critical",
            "pattern": "Use same nonce action in wp_create_nonce() and wp_verify_nonce()",
            "example": "JavaScript: wp_create_nonce('plugin_nonce'), PHP: wp_verify_nonce(..., 'plugin_nonce')",
            "critical": "Mismatched nonces cause 401 errors and broken functionality"
        },
        "loggingSystem": {
            "rule": "Implement comprehensive logging for debugging",
            "structure": "Custom log directory in wp-content/uploads/plugin-logs/",
            "protection": "Add .htaccess to prevent direct access to log files",
            "rotation": "Implement log rotation when files exceed 5MB",
            "functions": "Separate functions for logging, retrieving, and clearing logs",
            "levels": "Support info, warning, error levels with context data"
        },
        "functionDuplication": {
            "rule": "NEVER declare the same function twice",
            "check": "Use grep to find duplicate function declarations before adding new ones",
            "solution": "Remove old implementations when adding new ones",
            "testing": "Always run 'php -l' after function changes"
        },
        "menuIntegration": {
            "rule": "Properly integrate with existing Shift8 menu structure",
            "pattern": "Check if main menu exists before creating, add submenu items only",
            "duplication": "Avoid creating duplicate menu items by checking $GLOBALS['admin_page_hooks']",
            "testing": "Deactivate/reactivate plugin to clear WordPress menu cache"
        },
        "userExperience": {
            "rule": "Eliminate annoying user interface behaviors",
            "unsavedWarnings": "Don't show 'unsaved changes' warnings on every field change",
            "feedback": "Always provide clear success/error messages for user actions",
            "testing": "Actually test every button and form to ensure they work as expected"
        },
        "tokenHandling": {
            "rule": "Handle JWT tokens intelligently for both encrypted and plain text scenarios",
            "detection": "Check if token starts with 'eyJ' to identify JWT format",
            "encryption": "Encrypt tokens for storage but handle plain JWT gracefully",
            "consistency": "Ensure web dashboard and WP-CLI use identical token processing logic",
            "fallback": "Implement smart fallback for tokens that may be stored in different formats"
        },
        "settingsEvolution": {
            "rule": "Handle settings schema changes gracefully during plugin updates",
            "migration": "Provide migration logic when removing or renaming settings fields",
            "defaults": "Always set sensible defaults for new settings to prevent validation errors",
            "cleanup": "Remove obsolete settings from database during updates",
            "testing": "Test settings page with both old and new setting structures"
        }
    },
    "testingProtocol": {
        "description": "Mandatory testing steps after major changes - ZERO TOLERANCE FOR FAILURES",
        "zeroTolerancePolicy": {
            "rule": "ABSOLUTELY NO test failures are acceptable - 0 errors, 0 failures, 0 exceptions",
            "enforcement": "Every single test must pass before any code is considered complete",
            "process": [
                "Run 'php -l' syntax check on all modified files",
                "Run 'wp eval \"echo 'WordPress loads OK';\"' after ANY significant changes",
                "Run 'composer test' after every change",
                "Fix ALL failures immediately - no exceptions",
                "Never accept 'mostly working' or 'good enough' test results",
                "Each failure must be investigated and resolved completely",
                "Update mocks, fix logic errors, correct assertions - whatever it takes"
            ]
        },
        "mandatoryChecks": {
            "rule": "ALWAYS run these checks after significant code changes",
            "order": [
                "1. PHP syntax check: php -l [modified-files]",
                "2. WordPress load test: wp eval \"echo 'WordPress loads OK';\"",
                "3. Plugin class test: wp eval \"if (class_exists('Shift8_TREB')) echo 'Plugin loads OK'; else echo 'PLUGIN LOAD FAILED';\"",
                "4. Unit tests: composer test"
            ],
            "critical": "If ANY check fails, STOP and fix immediately before proceeding"
        },
        "syntaxCheck": {
            "command": "php -l filename.php",
            "description": "Check for PHP syntax errors in all modified files"
        },
        "wordpressEval": {
            "command": "wp eval \"echo 'Test passed';\"",
            "description": "Verify WordPress can load without fatal errors"
        },
        "pluginLoad": {
            "command": "wp eval \"if (class_exists('Plugin_Class')) echo 'OK'; else echo 'FAIL';\"",
            "description": "Verify main plugin class loads correctly"
        },
        "testExecution": {
            "command": "composer test",
            "requirement": "MUST show 'OK (X tests, Y assertions)' with NO errors or failures AND exit code 0",
            "exitCodeAwareness": {
                "rule": "ALWAYS check exit code, not just test output - non-zero exit code means failure",
                "critical": "Exit code 255 or any non-zero code indicates failure even if tests appear to pass",
                "examples": {
                    "success": "Exit code: 0 - All tests passed and coverage generated successfully",
                    "failure": "Exit code: 255 - Tests may pass but coverage generation or other steps failed"
                },
                "verification": "Check both test output AND command exit code before declaring success"
            },
            "failureResponse": "Immediately investigate and fix every single failure including non-zero exit codes"
        },
        "phpunitConfiguration": {
            "description": "PHPUnit configuration best practices for WordPress plugins",
            "coverageExclusions": {
                "rule": "Always exclude duplicate class files and non-code directories from coverage",
                "requiredExclusions": [
                    "tests/ - test files themselves",
                    "vendor/ - third-party dependencies",
                    "svn/ - WordPress.org SVN directory with duplicate code",
                    "languages/ - translation files",
                    "admin/ - if not testing admin classes directly"
                ],
                "rationale": "SVN directory contains trunk/ and tags/ with duplicate classes causing fatal errors",
                "symptom": "Fatal error: Cannot declare class X, because the name is already in use",
                "solution": "Add <directory>svn</directory> to <exclude> section in phpunit.xml"
            },
            "svnDirectoryIssue": {
                "problem": "WordPress.org plugins often have svn/trunk/ and svn/tags/ directories that duplicate main codebase",
                "consequence": "Code coverage tool includes these files causing 'class already declared' fatal errors",
                "detection": "Exit code 255 with 'Cannot declare class' error during coverage generation",
                "fix": "Add svn directory to coverage exclusions in phpunit.xml",
                "prevention": "Always exclude version control directories (svn/, .git/) from PHPUnit coverage"
            }
        },
        "functionalTesting": {
            "description": "Manual testing checklist",
            "steps": [
                "Test settings save button works and shows success message",
                "Test API connection button works without 401 errors",
                "Test manual sync button works and generates logs",
                "Test log viewer shows actual log content",
                "Test clear logs function works",
                "Verify no duplicate menu items appear",
                "Test WP-CLI commands work properly"
            ]
        }
    },
    "wpCliIntegration": {
        "description": "WP-CLI command implementation best practices",
        "commandStructure": {
            "rule": "Create comprehensive CLI commands for all major plugin functions",
            "pattern": "Use WP_CLI::add_command() to register command classes",
            "organization": "Separate CLI class in includes/class-plugin-cli.php",
            "conditional": "Only load CLI class when WP-CLI is available: if (defined('WP_CLI') && WP_CLI)"
        },
        "commandFeatures": {
            "helpText": "Provide detailed help text with examples for all commands",
            "options": "Support --dry-run, --verbose, --limit, --force options where appropriate",
            "progressBars": "Use WP_CLI\\Utils\\make_progress_bar for long operations",
            "formatting": "Support multiple output formats (table, json, yaml) for data commands",
            "errorHandling": "Use WP_CLI::error() for fatal errors, WP_CLI::warning() for non-fatal issues"
        },
        "commonCommands": {
            "sync": "Manual sync with dry-run capability and progress tracking",
            "settings": "Display current plugin configuration",
            "test": "Test external API connections",
            "logs": "View and manage log files",
            "clear": "Clear caches, logs, or reset data with confirmation prompts"
        },
        "security": {
            "rule": "CLI commands should respect WordPress permissions and plugin settings",
            "validation": "Validate all input parameters and provide meaningful error messages",
            "confirmation": "Use WP_CLI::confirm() for destructive operations unless --yes flag is used"
        }
    },
    "loggingBestPractices": {
        "description": "Comprehensive logging system implementation",
        "fileStructure": {
            "location": "wp-content/uploads/plugin-name-logs/",
            "protection": "Always create .htaccess to deny direct access",
            "rotation": "Implement automatic log rotation at 5MB with backup retention",
            "naming": "Use descriptive log file names (plugin-sync.log, not debug.log)"
        },
        "logLevels": {
            "info": "General operational messages and successful operations",
            "warning": "Non-fatal issues that should be noted",
            "error": "Fatal errors and exceptions that prevent operation",
            "context": "Always include relevant context data as second parameter"
        },
        "functions": {
            "write": "Centralized logging function with level support and context",
            "read": "Function to retrieve recent log entries with line limits",
            "clear": "Function to safely clear logs with user confirmation",
            "rotate": "Automatic rotation when files exceed size limits"
        },
        "integration": {
            "rule": "Log all major operations, API calls, and user actions",
            "timing": "Log start and completion of long operations",
            "errors": "Always log exceptions with full context and stack traces",
            "debugging": "Respect debug mode settings but always log errors/warnings"
        }
    },
    "apiIntegrationPatterns": {
        "description": "Best practices for external API integration",
        "serviceClasses": {
            "rule": "Create dedicated service classes for each external API",
            "structure": "Separate connection testing, data fetching, and error handling methods",
            "configuration": "Accept settings array in constructor for flexibility",
            "caching": "Implement appropriate caching for API responses"
        },
        "errorHandling": {
            "rule": "Graceful degradation when APIs are unavailable",
            "logging": "Log all API errors with request/response details",
            "retries": "Implement exponential backoff for transient failures",
            "fallbacks": "Provide meaningful fallback behavior when APIs fail"
        },
        "authentication": {
            "rule": "Securely handle API credentials and tokens",
            "storage": "Encrypt sensitive credentials before database storage",
            "transmission": "Use proper headers and HTTPS for API communication",
            "validation": "Test credentials before saving and provide clear feedback"
        }
    },
    "externalApiPatterns": {
        "description": "Patterns learned from AMPRE API integration",
        "curlTesting": {
            "rule": "ALWAYS test API queries with curl before coding",
            "process": [
                "Test basic connectivity with simple queries",
                "Validate filter syntax and parameter encoding",
                "Confirm response structure matches expectations",
                "Test edge cases like empty results and error responses"
            ],
            "benefits": "Prevents 400/401 errors and saves debugging time"
        },
        "incrementalSync": {
            "rule": "Implement timestamp-based incremental synchronization",
            "pattern": "Store last_sync_timestamp and use ModificationTimestamp ge [timestamp]",
            "fallback": "Use listing_age_days filter when no previous sync timestamp exists",
            "efficiency": "Dramatically reduces API calls and processing time for large datasets"
        },
        "memberBasedCategorization": {
            "rule": "Use agent/member ID for automatic content categorization",
            "implementation": "Compare ListAgentKey with configured member_id for ownership determination",
            "categories": "Own listings → 'Listings', others → 'OtherListings'",
            "scalability": "Supports comma-separated member IDs (e.g., '2229166,9580044') for multiple agents",
            "parsing": "Use array_map('trim', explode(',', $member_ids)) and in_array() for matching"
        },
        "queryStructureCompliance": {
            "rule": "Follow API documentation query patterns exactly",
            "ordering": "Use documented $orderby patterns (ModificationTimestamp,ListingKey)",
            "filtering": "Use proper OData syntax without double URL encoding",
            "expansion": "Avoid unsupported $expand operations that cause 400 errors",
            "testing": "Validate each query component individually before combining"
        }
    },
    "templatePlaceholderSystems": {
        "description": "Best practices for template placeholder replacement and content generation",
        "placeholderMismatch": {
            "rule": "Always investigate template vs code placeholder mismatches",
            "process": [
                "Examine actual post content to identify which placeholders are not being replaced",
                "Compare template placeholders with code replacement arrays",
                "Add missing placeholders to maintain backward compatibility",
                "Support both old and new placeholder formats for flexibility"
            ],
            "example": "Template uses %MLSNUMBER% but code replaces %MLS% - add both for compatibility"
        },
        "addressParsing": {
            "rule": "Implement robust address parsing for street components",
            "components": "Extract street number, street name, and unit from full address",
            "patterns": "Use regex patterns for common address formats (Unit, Apt, Suite, #)",
            "fallbacks": "Provide empty strings for missing components to prevent template errors"
        },
        "dynamicContent": {
            "rule": "Generate dynamic content based on listing data availability",
            "conditionalContent": "Only show virtual tours, WalkScore, etc. if data is available",
            "gracefulDegradation": "Return empty strings for missing data rather than errors",
            "extensibility": "Design placeholder system to easily add new dynamic content types"
        },
        "shortcodeCompatibility": {
            "rule": "Ensure template content works with all page builders",
            "preservation": "Store shortcodes as-is in post content, don't process during save",
            "processing": "Let WordPress and page builders handle shortcode processing on display",
            "universality": "Template system should work with Visual Composer, Elementor, Gutenberg, Bricks"
        }
    },
    "debuggingPatterns": {
        "description": "Systematic debugging approaches for complex plugin issues",
        "placeholderDebugging": {
            "rule": "Use wp-cli to examine actual post content when placeholders aren't working",
            "commands": [
                "wp post list --meta_key=listing_mls_number --fields=ID,post_title,post_content",
                "wp post get [ID] --field=post_content | head -20",
                "Compare template expectations with actual replacement arrays"
            ],
            "analysis": "Look for patterns in what's replaced vs what's not replaced"
        },
        "cronDebugging": {
            "rule": "Use wp-cli cron commands to verify scheduling and execution",
            "commands": [
                "wp cron event list | grep [plugin]",
                "wp cron schedule list | grep [plugin]",
                "wp plugin deactivate/activate to test activation hooks"
            ],
            "verification": "Always test activation/deactivation cron management"
        },
        "apiDebugging": {
            "rule": "Test API queries with curl before implementing in code",
            "process": [
                "Test basic connectivity and authentication",
                "Validate query parameters and response structure",
                "Test edge cases and error conditions",
                "Implement incremental complexity (simple → complex queries)"
            ],
            "benefits": "Prevents 400/401 errors and saves debugging time in code"
        }
    },
    "activationDeactivationPatterns": {
        "description": "Best practices for plugin lifecycle management",
        "cronManagement": {
            "rule": "Always schedule cron jobs on activation and clear on deactivation",
            "activation": "Call schedule_sync() or equivalent in activate() method",
            "deactivation": "Use wp_clear_scheduled_hook() to clean up all plugin events",
            "testing": "Test deactivate/activate cycle to ensure proper cleanup and rescheduling"
        },
        "settingsInitialization": {
            "rule": "Set sensible defaults on activation, preserve user settings",
            "defaults": "Use add_option() to set defaults without overwriting existing settings",
            "migration": "Handle settings schema changes gracefully during updates",
            "cleanup": "Consider whether to preserve or clean settings on deactivation"
        },
        "directoryCreation": {
            "rule": "Create necessary directories and files on activation",
            "uploads": "Create plugin-specific upload directories for logs, images, etc.",
            "permissions": "Use wp_mkdir_p() and check directory permissions",
            "protection": "Add .htaccess files to protect sensitive directories"
        }
    },
    "testMaintenancePatterns": {
        "description": "Patterns for maintaining test suites during feature evolution",
        "settingsSchemaChanges": {
            "rule": "Update test settings when removing/adding configuration fields",
            "process": [
                "Identify all test files that use old settings structure",
                "Update test settings arrays to match new schema",
                "Modify test assertions to expect new query parameters",
                "Remove tests for deprecated functionality"
            ],
            "critical": "Test failures after settings changes indicate incomplete migration"
        },
        "mockingEvolution": {
            "rule": "Evolve WordPress function mocks as plugin functionality grows",
            "additions": "Add new WordPress function mocks when introducing new features",
            "organization": "Group related mocks together (e.g., post functions, category functions)",
            "coverage": "Ensure all WordPress functions used in code have corresponding mocks"
        },
        "complexMethodTesting": {
            "rule": "Test complex methods pragmatically in constrained environments",
            "approach": "Focus on business logic validation rather than complete integration testing",
            "examples": {
                "fileOperations": "Test URL validation and error handling rather than complete file upload flow",
                "apiIntegration": "Test query building and response parsing rather than actual HTTP calls",
                "imageProcessing": "Test validation logic rather than complete WordPress media library integration"
            },
            "rationale": "Complex WordPress integrations are difficult to mock completely in unit tests"
        }
    },
    "categoryManagementPatterns": {
        "description": "Best practices for WordPress category and taxonomy management",
        "dynamicCategorization": {
            "rule": "Implement dynamic category assignment based on business rules",
            "implementation": "Use agent/member ID matching for automatic categorization",
            "categories": "Create meaningful category names (e.g., 'Listings' vs 'OtherListings')",
            "debugging": "Add debug logging to category assignment logic for troubleshooting"
        },
        "categoryCreation": {
            "rule": "Automatically create categories when they don't exist",
            "pattern": "Use get_category_by_slug() first, then wp_insert_category() if needed",
            "errorHandling": "Handle category creation failures gracefully",
            "consistency": "Ensure category names are consistent across the application"
        }
    },
    "conditionalApiIntegration": {
        "description": "Best practices for optional third-party API integrations",
        "apiKeyValidation": {
            "rule": "Always check for API key presence before attempting API calls",
            "pattern": "if (empty($this->settings['api_key'])) { return fallback_value; }",
            "examples": {
                "geocoding": "Only attempt Google Maps geocoding if API key is configured",
                "walkscore": "Only generate WalkScore widgets if both API key and ID are present"
            }
        },
        "gracefulDegradation": {
            "rule": "Provide meaningful fallbacks when APIs are unavailable",
            "geocoding": "Fall back to default coordinates (e.g., Toronto) when geocoding fails",
            "widgets": "Return empty string for widget code when API credentials are missing",
            "caching": "Cache API responses to reduce dependency on external services"
        }
    },
    "universalTemplateDesign": {
        "description": "Patterns for creating page builder agnostic template systems",
        "placeholderSystem": {
            "rule": "Design placeholder systems that work across different page builders",
            "approach": "Use WordPress native systems (featured images, galleries) as foundation",
            "placeholders": "Provide multiple placeholder formats for different use cases",
            "examples": {
                "images": "%FEATURED_IMAGE%, %IMAGE_GALLERY%, %LISTING_IMAGE_1%, %BASE64IMAGES%",
                "coordinates": "%MAPLAT%, %MAPLNG% with geocoding fallbacks",
                "widgets": "%WALKSCORECODE% with conditional generation"
            }
        },
        "pageBuilderCompatibility": {
            "rule": "Store content in post_content for universal compatibility",
            "rationale": "All page builders fall back to rendering post_content if they don't have custom data",
            "shortcodes": "Store shortcodes as-is, let WordPress process them on display",
            "universality": "Template system should work with Visual Composer, Elementor, Gutenberg, Bricks"
        }
    },
    "codeDuplicationPrevention": {
        "description": "Critical patterns learned today to prevent code duplication and maintain DRY principles",
        "sharedServicePattern": {
            "rule": "Create shared service classes for complex operations used by multiple components",
            "implementation": "Extract common logic into dedicated service classes (e.g., Sync_Service)",
            "benefits": "Eliminates duplication between CLI, Cron, and Admin operations",
            "example": "CLI and Cron sync both use Shift8_TREB_Sync_Service instead of duplicating 200+ lines",
            "testability": "Shared services are easier to unit test and mock"
        },
        "serviceFactoryPattern": {
            "rule": "Use factory methods or dependency injection for service instantiation",
            "avoidDuplication": "Don't repeat require_once and new Class() patterns across files",
            "centralization": "Centralize service creation and configuration in one place",
            "consistency": "Ensures all components use services with identical configuration"
        },
        "settingsManagementPattern": {
            "rule": "Centralize settings processing and validation logic",
            "avoidDuplication": "Don't repeat settings loading, decryption, and validation logic",
            "implementation": "Create prepare_settings() methods in service classes",
            "benefits": "Consistent settings handling across CLI, Cron, and Admin interfaces"
        },
        "errorHandlingPattern": {
            "rule": "Create shared error handling and logging utilities",
            "avoidDuplication": "Don't repeat try-catch patterns and logging calls",
            "implementation": "Standardize error handling in service classes",
            "consistency": "Uniform error messages and logging across all components"
        }
    },
    "securityBestPracticesLearned": {
        "description": "Security patterns reinforced and learned during today's development",
        "inputSanitizationConsistency": {
            "rule": "ALWAYS sanitize exception messages and user input consistently",
            "pattern": "Use esc_html() even for exception messages: esc_html($e->getMessage())",
            "rationale": "Exception messages can contain user input and must be escaped",
            "testing": "Unit tests must mock esc_html() to catch missing sanitization"
        },
        "functionMockingForSecurity": {
            "rule": "Mock ALL WordPress security functions in tests to catch missing sanitization",
            "functions": ["esc_html()", "esc_attr()", "esc_js()", "sanitize_text_field()"],
            "implementation": "Add mocks to tests/bootstrap.php and individual test setUp() methods",
            "benefits": "Tests fail immediately when security functions are missing"
        },
        "settingsSecurityPattern": {
            "rule": "Implement secure settings handling with proper encryption and validation",
            "encryption": "Always encrypt sensitive data (bearer tokens) before storage",
            "validation": "Sanitize and validate all settings input with proper bounds checking",
            "preservation": "Preserve existing encrypted values when form fields are empty"
        },
        "apiCredentialHandling": {
            "rule": "Handle API credentials securely with intelligent detection",
            "detection": "Detect plain vs encrypted tokens intelligently (e.g., JWT format detection)",
            "storage": "Always store in encrypted format, decrypt only when needed",
            "fallback": "Provide graceful fallback for different token formats during migration"
        }
    },
    "testingBestPracticesReinforced": {
        "description": "Testing patterns that proved critical for maintaining code quality",
        "zeroTolerancePolicy": {
            "rule": "ABSOLUTELY ZERO test failures are acceptable - 0 errors, 0 failures, 0 exceptions",
            "enforcement": "Every single test must pass before any code is considered complete",
            "process": [
                "Run 'php -l' syntax check on all modified files",
                "Run 'composer test' after every change",
                "Fix ALL failures immediately - no exceptions",
                "Each failure must be investigated and resolved completely"
            ],
            "learned": "Today we went from 27 errors + 5 failures to 62 tests passing with 139 assertions"
        },
        "comprehensiveTestCoverage": {
            "rule": "Add tests for ALL new methods and features immediately",
            "newFeatures": "Every new method needs corresponding unit tests",
            "mockingStrategy": "Mock ALL WordPress functions used in new code",
            "edgeCases": "Test both success and failure scenarios, empty inputs, and boundary conditions"
        },
        "testMaintenancePatterns": {
            "rule": "Update tests immediately when refactoring or changing functionality",
            "settingsChanges": "Update test settings when removing/adding configuration fields",
            "methodRenames": "Update reflection calls when private method names change",
            "mockEvolution": "Add new WordPress function mocks when introducing new features"
        }
    },
    "performanceOptimizationPatterns": {
        "description": "Performance patterns learned during image processing and sync optimization",
        "batchProcessingPattern": {
            "rule": "Implement batch processing for I/O intensive operations",
            "implementation": "Process items in small batches (3-5) with short delays between batches",
            "benefits": "Simulates concurrency, reduces memory usage, prevents server overload",
            "example": "Image downloads went from sequential to batched processing for 3x speed improvement"
        },
        "conditionalProcessingPattern": {
            "rule": "Make expensive operations conditional with settings flags",
            "implementation": "Add skip_image_download and batch_image_processing flags",
            "benefits": "Allows fast sync modes and performance tuning based on needs",
            "userExperience": "Provide CLI flags for different performance modes"
        },
        "timeoutOptimization": {
            "rule": "Optimize timeouts for external API calls based on use case",
            "implementation": "Use shorter timeouts (8-10s) for non-critical operations like images",
            "benefits": "Prevents slow external services from blocking entire sync process",
            "fallback": "Always provide fallback behavior when timeouts occur"
        }
    },
    "securityAuditProtocol": {
        "description": "Comprehensive security audit procedures based on WordPress.org plugin directory requirements",
        "criticalSecurityIssues": {
            "rule": "Identify and fix critical security vulnerabilities immediately",
            "xssVulnerabilities": {
                "issue": "Unescaped output in JavaScript and HTML contexts",
                "detection": "Look for wp_create_nonce(), dynamic content in JS, unescaped variables",
                "fixes": ["Wrap wp_create_nonce() with esc_js() in JavaScript", "Use esc_html() for all dynamic content", "Escape all exception messages with esc_html()"],
                "priority": "CRITICAL - Fix immediately"
            },
            "inconsistentEscaping": {
                "issue": "Some dynamic content escaped, others not",
                "detection": "Search for throw new Exception(), echo statements, HTML attributes",
                "fixes": ["Wrap ALL exception messages in esc_html()", "Escape all variables in HTML context", "Use esc_attr() for HTML attributes"],
                "priority": "CRITICAL - Fix immediately"
            },
            "legacyInsecureCode": {
                "issue": "Old code patterns that don't follow current security standards",
                "detection": "Look for unused methods, duplicate logic, inconsistent patterns",
                "fixes": ["Remove unused methods", "Consolidate duplicate security logic", "Apply consistent escaping patterns"],
                "priority": "HIGH - Fix during refactoring"
            }
        },
        "auditChecklist": {
            "rule": "Run comprehensive security audit before any release",
            "steps": [
                "1. Search for all wp_create_nonce() calls and ensure esc_js() wrapping",
                "2. Search for all 'throw new Exception' and ensure esc_html() on messages",
                "3. Search for all echo/print statements and verify escaping",
                "4. Search for all HTML attributes and verify esc_attr() usage",
                "5. Review all $_POST/$_GET handling for sanitization",
                "6. Check all nonce verification patterns",
                "7. Verify capability checks on all admin functions",
                "8. Review file operation security (use WP_Filesystem)",
                "9. Check for exposed endpoints or direct file access"
            ]
        },
        "automatedSecurityScanning": {
            "rule": "Use grep patterns to find common security issues",
            "patterns": {
                "unescapedNonces": "grep -r \"wp_create_nonce\" --include=\"*.php\" | grep -v \"esc_js\"",
                "unescapedExceptions": "grep -r \"throw new Exception\" --include=\"*.php\" | grep -v \"esc_html\"",
                "directOutput": "grep -r \"echo \\|print \" --include=\"*.php\" | grep -v \"esc_\"",
                "unsanitizedInput": "grep -r \"\\$_POST\\|\\$_GET\" --include=\"*.php\" | grep -v \"sanitize_\\|wp_unslash\""
            }
        }
    },
    "deadCodeAuditProtocol": {
        "description": "Systematic approach to identifying and removing unused code",
        "identificationProcess": {
            "rule": "Use systematic analysis to find unused code",
            "steps": [
                "1. List all function definitions: grep -r \"function \" --include=\"*.php\"",
                "2. List all class methods: grep -r \"public function\\|private function\\|protected function\"",
                "3. Search for usage of each function across codebase",
                "4. Identify functions only called from other unused functions",
                "5. Check for unused variables, constants, and includes"
            ]
        },
        "safeRemovalCriteria": {
            "rule": "Only remove code that is definitively unused",
            "criteria": [
                "Function has zero references in codebase",
                "Method is not called by any other methods",
                "Not part of WordPress hooks or callbacks",
                "Not used in templates or external integrations",
                "Not part of public API or interface"
            ]
        },
        "removalProcess": {
            "rule": "Remove dead code systematically with verification",
            "steps": [
                "1. Remove the unused function/method",
                "2. Run php -l syntax check on modified files",
                "3. Run full test suite to verify no regressions",
                "4. Test core functionality manually",
                "5. Document removal in commit message"
            ]
        },
        "commonDeadCodePatterns": {
            "rule": "Recognize common patterns of dead code",
            "patterns": [
                "Wrapper functions that just call other functions",
                "Methods created during development but never integrated",
                "Duplicate implementations of same functionality",
                "Legacy code replaced by newer implementations",
                "Helper functions that are no longer needed"
            ]
        }
    },
    "codeDuplicationAuditProtocol": {
        "description": "Systematic approach to identifying and consolidating duplicate code",
        "duplicationIdentificationProcess": {
            "rule": "Use systematic analysis to find code duplication",
            "steps": [
                "1. Identify functions with similar names or purposes",
                "2. Compare method implementations for similar logic",
                "3. Look for repeated patterns in settings handling",
                "4. Find duplicate validation/sanitization logic",
                "5. Identify scattered authentication/encryption code"
            ]
        },
        "riskAssessmentMatrix": {
            "rule": "Assess consolidation risk before making changes",
            "lowRisk": {
                "criteria": ["Simple wrapper functions", "Identical logic with no context differences", "Pure utility functions"],
                "action": "Safe to consolidate immediately",
                "examples": ["Logging wrapper functions", "Common sanitization patterns"]
            },
            "mediumRisk": {
                "criteria": ["Similar logic but different contexts", "Shared core logic with different error handling", "Different parameter validation"],
                "action": "Consolidate with careful testing",
                "examples": ["Image processing methods", "API request handling"]
            },
            "highRisk": {
                "criteria": ["Different business logic", "Different security requirements", "Core functionality differences"],
                "action": "Requires careful analysis and extensive testing",
                "examples": ["Settings registration", "Authentication handling"]
            }
        },
        "consolidationStrategies": {
            "rule": "Choose appropriate consolidation strategy based on risk",
            "strategies": {
                "extractCommonMethod": "Extract shared logic into private method called by both functions",
                "createServiceClass": "Move complex shared logic into dedicated service class",
                "useFactoryPattern": "Centralize object creation and configuration",
                "createUtilityClass": "Group related utility functions into static class"
            }
        },
        "consolidationProcess": {
            "rule": "Follow systematic process for safe consolidation",
            "steps": [
                "1. Identify exact differences between duplicate code",
                "2. Design consolidation strategy (extract method, service class, etc.)",
                "3. Implement consolidation with backward compatibility",
                "4. Update all references to use consolidated code",
                "5. Run comprehensive tests (syntax, unit, functional)",
                "6. Remove original duplicate code",
                "7. Verify no regressions in functionality"
            ]
        }
    },
    "codeQualityMaintenance": {
        "description": "Ongoing practices to maintain high code quality and prevent technical debt",
        "preventiveMeasures": {
            "rule": "Implement practices to prevent code quality issues",
            "practices": [
                "Review all new functions for potential duplication before adding",
                "Use consistent naming conventions to avoid similar functions",
                "Implement shared services for complex operations from the start",
                "Create utility classes for common operations",
                "Document function purposes to avoid reimplementation"
            ]
        },
        "regularAudits": {
            "rule": "Schedule regular code quality audits",
            "frequency": "After every major feature addition or monthly",
            "audits": [
                "Dead code audit using grep patterns",
                "Duplication audit comparing similar functions",
                "Security audit using automated scanning patterns",
                "Performance audit for optimization opportunities",
                "Test coverage audit for missing tests"
            ]
        },
        "refactoringGuidelines": {
            "rule": "Follow safe refactoring practices",
            "principles": [
                "Make small, incremental changes",
                "Test after each refactoring step",
                "Maintain backward compatibility when possible",
                "Document breaking changes clearly",
                "Use feature flags for risky changes"
            ]
        }
    },
    "googleMapsIntegrationPatterns": {
        "description": "Best practices for Google Maps integration in WordPress plugins",
        "conditionalDisplay": {
            "rule": "Only display maps when all requirements are met",
            "requirements": ["Google Maps API key configured", "Valid coordinates available", "Single post context"],
            "implementation": "Use helper functions like shift8_treb_has_google_maps_api_key() and shift8_treb_has_listing_coordinates()",
            "avoidConflicts": "Only enqueue scripts on single listing posts to prevent JavaScript conflicts"
        },
        "wordpressNamingConventions": {
            "rule": "Follow WordPress function naming conventions for uniqueness",
            "pattern": "prefix_plugin_function_name (e.g., shift8_treb_init_map)",
            "avoidGeneric": "Don't use generic names like initMap() that could conflict with other plugins",
            "consistency": "Apply consistent naming across all JavaScript functions and callbacks"
        },
        "placeholderSystem": {
            "rule": "Integrate maps seamlessly with template placeholder system",
            "placeholder": "%GOOGLEMAPCODE% - generates conditional map HTML",
            "htmlStructure": "Use semantic HTML: <div class=\"shift8-treb-googlemap\" id=\"shift8-treb-map\">",
            "fallback": "Return empty string when requirements not met for graceful degradation"
        }
    },
    "directMlsImportPatterns": {
        "description": "Patterns for implementing direct MLS import functionality",
        "cliCommandDesign": {
            "rule": "Create intuitive CLI commands for direct operations",
            "pattern": "wp shift8-treb import MLS1,MLS2,MLS3",
            "options": "Support --dry-run, --verbose, --limit for flexibility",
            "feedback": "Provide clear progress indicators and summary statistics"
        },
        "codeReuse": {
            "rule": "Reuse existing sync logic to avoid duplication",
            "implementation": "Use shared service classes (e.g., Sync_Service) for core logic",
            "benefits": "Ensures identical processing between normal sync and direct import",
            "testing": "Same test coverage applies to both sync methods"
        },
        "orphanedImageHandling": {
            "rule": "Handle orphaned images from previous imports gracefully",
            "detection": "Check for existing images with post_parent = 0",
            "correction": "Implement auto-correction to attach orphaned images to correct posts",
            "logging": "Log post_parent mismatches for debugging and monitoring"
        }
    },
    "apiDiagnosticsPatterns": {
        "description": "Patterns for implementing API diagnostic tools",
        "rawDataAnalysis": {
            "rule": "Provide raw API response analysis without full processing",
            "implementation": "Create analyze command that fetches data without creating posts",
            "benefits": "Fast diagnostics, troubleshooting without side effects",
            "features": "Support filtering, searching, agent analysis, date ranges"
        },
        "performanceOptimization": {
            "rule": "Optimize diagnostic commands for speed",
            "skipExpensiveOperations": "Skip image downloads, post creation, template processing",
            "focusOnData": "Focus on API response structure, agent IDs, timestamps, categorization logic",
            "quickFeedback": "Provide immediate feedback for troubleshooting sync issues"
        }
    },
    "syncModeManagementPatterns": {
        "description": "Patterns for managing different synchronization modes",
        "incrementalVsAgeBased": {
            "rule": "Provide clear control over sync modes with transparency",
            "incrementalSync": "Use ModificationTimestamp for efficiency but may miss deleted/re-imported posts",
            "ageBasedSync": "Use listing_age_days for comprehensive coverage including re-imports",
            "userControl": "Provide CLI commands to check status and reset modes"
        },
        "syncStatusTransparency": {
            "rule": "Make sync mode visible and understandable to users",
            "statusCommand": "wp shift8-treb sync_status shows current mode and implications",
            "resetCommand": "wp shift8-treb reset_sync provides easy mode switching",
            "documentation": "Clearly explain when to use each mode and trade-offs"
        },
        "uxConsiderations": {
            "rule": "Avoid invisible behaviors that confuse users",
            "problem": "Incremental sync timestamp is invisible and causes unexpected behavior",
            "solution": "Provide visibility and control over sync behavior",
            "prevention": "Always document automatic behaviors that affect user expectations"
        }
    },
    "uiUxBestPractices": {
        "description": "User interface and experience improvements learned",
        "eliminateAnnoyingBehaviors": {
            "rule": "Fix annoying UI behaviors that frustrate users",
            "multipleConfirmations": "Never show multiple confirmation dialogs for single actions",
            "debugging": "Check for duplicate event handlers in JavaScript",
            "solution": "Consolidate confirmation logic and remove duplicate handlers"
        },
        "feedbackClarity": {
            "rule": "Provide clear, immediate feedback for user actions",
            "successMessages": "Always show success confirmation for completed actions",
            "errorMessages": "Provide specific, actionable error messages",
            "progressIndicators": "Show progress for long-running operations"
        }
    },
    "wordpressPluginDirectoryReadiness": {
        "description": "Patterns for WordPress.org plugin directory submission",
        "dualReadmeStrategy": {
            "rule": "Maintain both README.md and readme.txt with synchronized content",
            "readmeMd": "GitHub/development focused with technical details and CLI commands",
            "readmeTxt": "WordPress.org focused with user-friendly descriptions and FAQ",
            "synchronization": "Keep feature lists, changelogs, and core information synchronized"
        },
        "changelogMaintenance": {
            "rule": "Maintain detailed changelogs for both technical and user audiences",
            "technicalChangelog": "Include implementation details, bug fixes, performance improvements",
            "userChangelog": "Focus on user-visible features, benefits, and upgrade notices",
            "versionConsistency": "Ensure version numbers match across all files and headers"
        }
    },
    "criticalBugPatterns": {
        "description": "Critical bug patterns learned from image processing failures and their systematic resolution",
        "missingProcessingInUpdatePath": {
            "rule": "ALWAYS ensure update and create paths have identical processing logic",
            "issue": "Update path missing critical processing steps that exist in create path",
            "detection": "Compare create_listing_post() and update_listing_post() methods for consistency",
            "solution": "Extract shared processing logic or ensure both paths call identical methods",
            "example": "Image processing was missing from update path, causing no images for existing posts",
            "prevention": "Use shared service methods for complex operations instead of duplicating logic"
        },
        "orphanedAttachmentHandling": {
            "rule": "Implement automatic detection and correction of orphaned WordPress attachments",
            "issue": "Attachments created with post_parent=0 instead of correct post ID",
            "detection": "Check attachment->post_parent matches expected post ID during processing",
            "autoCorrection": "Automatically fix orphaned attachments instead of skipping them",
            "logging": "Log all post_parent corrections for debugging and monitoring",
            "prevention": "Always verify post_parent immediately after wp_insert_attachment()"
        },
        "silentFailureDebugging": {
            "rule": "Add comprehensive debugging output for complex operations that can fail silently",
            "implementation": "Add detailed CLI output for each step of batch operations",
            "httpDebugging": "Log individual HTTP request/response status codes and errors",
            "progressTracking": "Show progress for each item in batch operations",
            "errorVisibility": "Make silent failures visible through detailed logging and CLI output"
        },
        "batchProcessingValidation": {
            "rule": "Validate that batch processing actually processes items instead of skipping them",
            "commonIssue": "Batch processing reports success but skips all items due to false positive checks",
            "validation": "Verify that batch_requests array is not empty before claiming success",
            "logging": "Log when items are skipped vs actually processed",
            "testing": "Test batch processing with known data to verify actual processing occurs"
        }
    },
    "wordpressMetaFieldBestPractices": {
        "description": "Best practices for WordPress custom meta field storage and management",
        "comprehensiveMetaStorage": {
            "rule": "Store comprehensive listing data as individual meta fields for extensibility",
            "implementation": "70+ meta fields with plugin-unique prefix (shift8_treb_)",
            "benefits": "Enables third-party integrations, custom queries, and future feature development",
            "keyNaming": "Use descriptive, consistent naming: shift8_treb_{category}_{field_name}",
            "typeSpecificSanitization": "Apply appropriate sanitization based on data type (text, int, float, boolean, datetime, url, textarea)"
        },
        "metaFieldCategories": {
            "rule": "Organize meta fields into logical categories for maintainability",
            "categories": {
                "identifiers": "ListingKey, ListAgentKey, ListingId",
                "location": "Address components, coordinates, postal codes",
                "financial": "Prices, taxes, fees, financial calculations",
                "physical": "Dimensions, room counts, property features",
                "temporal": "Dates, timestamps, age calculations",
                "media": "Image counts, virtual tour URLs",
                "calculated": "Price per sqft, days on market, derived values"
            }
        },
        "conditionalStorage": {
            "rule": "Only store non-empty values to keep database clean",
            "implementation": "Check for empty/null values before calling update_post_meta()",
            "benefits": "Reduces database bloat and improves query performance",
            "exception": "Store zero values for numeric fields where zero is meaningful"
        },
        "metaFieldTesting": {
            "rule": "Add comprehensive tests for meta field storage and retrieval",
            "coverage": "Test all data types, edge cases, and sanitization functions",
            "validation": "Verify correct meta keys are stored with expected values",
            "edgeCases": "Test empty data, malformed input, and boundary conditions"
        }
    },
    "syncConsistencyPatterns": {
        "description": "Patterns ensuring all sync methods (CLI, Cron, Web) use identical code paths",
        "sharedServiceArchitecture": {
            "rule": "ALL sync methods must use the same underlying service class",
            "implementation": "CLI, Cron, and Web sync all use Shift8_TREB_Sync_Service",
            "verification": "Trace all sync entry points to confirm they call execute_sync()",
            "benefits": "Ensures identical behavior, easier testing, single point of maintenance"
        },
        "configurationDifferences": {
            "rule": "Document and minimize configuration differences between sync methods",
            "allowedDifferences": "CLI can override settings, Cron uses saved settings, Web uses saved settings",
            "consistency": "Core processing logic must be identical regardless of entry point",
            "testing": "Test all sync methods to ensure they produce identical results with same settings"
        },
        "syncMethodValidation": {
            "rule": "Regularly verify all sync methods use shared code paths",
            "process": [
                "Trace CLI sync: wp shift8-treb sync → Sync_Service::execute_sync()",
                "Trace Cron sync: shift8_treb_sync_listings → sync_listings_cron() → Sync_Service::execute_sync()",
                "Trace Web sync: ajax_manual_sync() → sync_listings_cron() → Sync_Service::execute_sync()"
            ],
            "redFlag": "If any sync method bypasses the shared service, refactor immediately"
        }
    },
    "imageProcessingBestPractices": {
        "description": "Critical patterns for WordPress media library integration and image processing",
        "batchProcessingDefaults": {
            "rule": "Make batch processing the default for better performance and user experience",
            "implementation": "Default batch_image_processing to true, provide sequential fallback",
            "adaptiveSettings": "Automatically adjust batch size, timeouts, and delays based on hosting environment",
            "userControl": "Provide CLI flags and settings to override batch behavior when needed"
        },
        "attachmentLinkingValidation": {
            "rule": "Always validate and correct attachment post_parent relationships",
            "implementation": "Check attachment->post_parent immediately after creation",
            "autoCorrection": "Automatically fix mismatched post_parent values",
            "logging": "Log all post_parent corrections for monitoring",
            "prevention": "Use wp_insert_attachment() with correct post_parent parameter"
        },
        "existingAttachmentHandling": {
            "rule": "Handle existing attachments intelligently instead of skipping processing",
            "detection": "Check for existing attachments by MLS number and image number",
            "orphanedCorrection": "Fix orphaned attachments (post_parent=0) instead of skipping",
            "duplicatePrevention": "Avoid downloading duplicates while ensuring proper linking",
            "logging": "Log attachment reuse, corrections, and skipped downloads"
        },
        "httpRequestDebugging": {
            "rule": "Provide detailed debugging for HTTP requests in batch processing",
            "implementation": "Log each HTTP request URL, response code, and error messages",
            "cliOutput": "Show progress for each image download with status indicators",
            "errorHandling": "Distinguish between network errors, HTTP errors, and processing errors",
            "troubleshooting": "Enable users to identify specific images or URLs causing issues"
        }
    },
    "debuggingMethodology": {
        "description": "Systematic debugging approaches for complex WordPress plugin issues",
        "logAnalysisPatterns": {
            "rule": "Use log analysis to identify gaps in expected vs actual processing",
            "technique": "Compare CLI output with log entries to find missing processing steps",
            "example": "CLI shows 'Starting batch download' but logs show 'No images to download' indicates logic error",
            "tools": "Use tail, grep, and timestamp analysis to trace execution flow"
        },
        "attachmentDebugging": {
            "rule": "Use wp-cli to investigate attachment and post relationships",
            "commands": [
                "wp post list --post_type=attachment --post_parent=ID --fields=ID,post_title,post_parent",
                "wp post list --post_type=attachment --meta_key=_treb_mls_number --meta_value=MLS",
                "wp post get ID --field=post_content | head -20"
            ],
            "analysis": "Look for orphaned attachments, missing relationships, and content issues"
        },
        "progressiveDebugging": {
            "rule": "Add debugging output progressively to isolate issues",
            "approach": "Start with high-level progress, add detailed output for failing operations",
            "implementation": "Use WP_CLI::line() for immediate feedback, logs for detailed analysis",
            "cleanup": "Remove excessive debugging output once issues are resolved"
        }
    },
    "wordpressMediaLibraryIntegration": {
        "description": "Best practices for WordPress media library integration in plugins",
        "attachmentCreationBestPractices": {
            "rule": "Follow WordPress standards for programmatic attachment creation",
            "process": [
                "1. Download image with wp_remote_get()",
                "2. Save to uploads directory with wp_upload_bits()",
                "3. Create attachment with wp_insert_attachment() including post_parent",
                "4. Generate metadata with wp_generate_attachment_metadata()",
                "5. Update metadata with wp_update_attachment_metadata()",
                "6. Verify post_parent relationship and correct if needed"
            ],
            "errorHandling": "Clean up uploaded files if attachment creation fails",
            "metadata": "Always generate thumbnails and attachment metadata for proper WordPress integration"
        },
        "featuredImageManagement": {
            "rule": "Implement intelligent featured image selection with priority logic",
            "priority": "1. First image (image_number=1), 2. Preferred image, 3. First successful download",
            "implementation": "Track image priorities during batch processing",
            "validation": "Verify featured image is set using get_post_thumbnail_id()",
            "fallback": "Provide fallback logic if preferred images fail to download"
        },
        "mediaQueryOptimization": {
            "rule": "Optimize media queries for performance",
            "existingChecks": "Use efficient meta_query to check for existing attachments",
            "bulkOperations": "Process multiple attachments in batches to reduce database queries",
            "indexing": "Ensure custom meta fields used in queries are properly indexed"
        }
    },
    "apiLevelFilteringPatterns": {
        "description": "Best practices for implementing API-level filtering for performance optimization",
        "serverSideFiltering": {
            "rule": "Always prefer server-side filtering over client-side filtering for external APIs",
            "rationale": "Reduces bandwidth, improves performance, and minimizes processing overhead",
            "implementation": "Add filter parameters to API query strings instead of filtering results locally",
            "example": "Use ListAgentKey eq 'ID' in OData $filter instead of array_filter() on results"
        },
        "cliFilterFlags": {
            "rule": "Provide CLI flags for common filtering scenarios to improve developer experience",
            "pattern": "Add --{filter-type}-only flags for frequently used filters",
            "validation": "Always validate required settings are configured before applying filters",
            "feedback": "Provide clear CLI output showing what filtering is being applied",
            "examples": {
                "membersOnly": "--members-only flag filters ListAgentKey at API level",
                "statusFilter": "--active-only could filter ContractStatus at API level",
                "dateFilter": "--recent-only could filter ModificationTimestamp at API level"
            }
        },
        "odataFilterSyntax": {
            "rule": "Follow OData filter syntax exactly for external API compatibility",
            "multipleValues": "Use (field eq 'value1' or field eq 'value2') for multiple values",
            "sanitization": "Always sanitize filter values with sanitize_text_field()",
            "testing": "Test filter syntax with curl before implementing in code",
            "documentation": "Document filter syntax in CLI help and code comments"
        },
        "performanceMetrics": {
            "rule": "Measure and communicate performance improvements from API-level filtering",
            "measurement": "Compare result counts before and after filtering (e.g., 3 vs 100+ listings)",
            "communication": "Show performance benefits in CLI output and documentation",
            "monitoring": "Log filter effectiveness for optimization insights"
        }
    },
    "cliUserExperiencePatterns": {
        "description": "Patterns for creating intuitive and helpful CLI commands",
        "flagNaming": {
            "rule": "Use descriptive, intuitive flag names that clearly indicate their purpose",
            "pattern": "--{purpose}-only for filtering flags, --{action} for action flags",
            "consistency": "Maintain consistent naming patterns across all commands",
            "examples": {
                "good": "--members-only, --dry-run, --verbose, --skip-images",
                "bad": "--filter, --test, --debug, --no-img"
            }
        },
        "helpDocumentation": {
            "rule": "Provide comprehensive help documentation with practical examples",
            "structure": "Include description, options with explanations, and real-world examples",
            "examples": "Show common use cases and flag combinations",
            "validation": "Document prerequisites and error conditions"
        },
        "progressFeedback": {
            "rule": "Provide clear progress indicators and status messages for long-running operations",
            "immediate": "Show configuration and mode selection immediately",
            "progress": "Display progress for operations that take time",
            "results": "Summarize results with counts and success/failure indicators",
            "icons": "Use emoji icons for visual clarity (🎯 for targeting, ⚡ for performance, ✅ for success)"
        },
        "errorHandling": {
            "rule": "Provide actionable error messages with clear next steps",
            "validation": "Validate prerequisites before starting operations",
            "messages": "Explain what went wrong and how to fix it",
            "examples": "Show correct usage when validation fails"
        }
    },
    "settingsArchitecturePatterns": {
        "description": "Patterns for flexible settings architecture that supports CLI overrides",
        "overridePattern": {
            "rule": "Design settings system to support temporary CLI overrides without affecting stored settings",
            "implementation": "Use settings_overrides array that gets merged with base settings",
            "preservation": "Never modify stored settings from CLI operations",
            "flexibility": "Allow CLI to override any setting temporarily for testing and debugging"
        },
        "settingsValidation": {
            "rule": "Validate settings dependencies when CLI flags are used",
            "dependencies": "Check that required settings exist before allowing dependent flags",
            "examples": {
                "membersOnly": "Validate member_id is configured before allowing --members-only",
                "apiOperations": "Validate bearer_token before allowing API operations"
            },
            "feedback": "Provide clear error messages when dependencies are missing"
        },
        "settingsTransparency": {
            "rule": "Make CLI settings overrides visible to users for debugging",
            "display": "Show effective settings when --verbose flag is used",
            "highlighting": "Clearly indicate which settings are overridden vs stored",
            "debugging": "Help users understand why certain behavior is occurring"
        }
    },
    "openStreetMapIntegrationPatterns": {
        "description": "Best practices for OpenStreetMap Nominatim API integration and rate limiting",
        "rateLimitingCompliance": {
            "rule": "ALWAYS respect OpenStreetMap's 1 request per second rate limit",
            "implementation": "Use transients to track last request time and sleep() if needed",
            "pattern": "get_transient('api_last_request') + sleep() if time_since < 1 second",
            "consequences": "Violating rate limits can result in 429 errors and IP blocking",
            "logging": "Log all rate limiting events for monitoring and debugging"
        },
        "addressCleaningStrategies": {
            "rule": "Implement multiple address cleaning variations for better geocoding success",
            "approach": "Try multiple cleaned address formats in order of aggressiveness",
            "variations": [
                "Most aggressive: Remove unit numbers after street names",
                "Conservative: Keep original format but standardize",
                "Basic: Street + city only as last resort"
            ],
            "trebSpecificIssues": "TREB addresses often have unit numbers directly after street names (e.g., 'Street 1210')",
            "fallbackStrategy": "Try each variation until one succeeds, cache failures to avoid repeated attempts"
        },
        "geocodingErrorHandling": {
            "rule": "Implement comprehensive error handling for geocoding failures",
            "httpStatusCodes": "Handle 429 (rate limit), 200 (success), and other error codes specifically",
            "jsonValidation": "Always validate JSON responses and handle malformed data",
            "emptyResults": "Distinguish between API errors and 'no results found' scenarios",
            "caching": "Cache successful results for 7 days, failures for 1 hour only"
        },
        "loggingBestPractices": {
            "rule": "Provide detailed logging for geocoding operations",
            "logEntries": [
                "Rate limiting events with sleep duration",
                "Each geocoding attempt with variation number",
                "HTTP response codes and error details",
                "Successful geocoding with OpenStreetMap display name",
                "Cache hits vs API calls for performance monitoring"
            ],
            "context": "Always include original address, cleaned address, and attempt number in logs"
        },
        "testingConsiderations": {
            "rule": "Account for WordPress constants not available in test environment",
            "constants": "Replace MINUTE_IN_SECONDS, HOUR_IN_SECONDS, DAY_IN_SECONDS with numeric values",
            "mocking": "Mock get_transient() and set_transient() for rate limiting tests",
            "validation": "Test address cleaning variations with real TREB address formats"
        }
    },
    "externalApiRateLimitingPatterns": {
        "description": "General patterns for respecting external API rate limits",
        "universalPrinciples": {
            "rule": "Always research and implement rate limiting for external APIs",
            "research": "Check API documentation for rate limits before implementation",
            "implementation": "Use WordPress transients or database to track request timing",
            "gracefulHandling": "Handle rate limit responses (429) with exponential backoff",
            "monitoring": "Log rate limiting events for performance analysis"
        },
        "wordpressIntegration": {
            "rule": "Use WordPress-native caching for rate limiting",
            "transients": "Use get_transient()/set_transient() for temporary rate limit tracking",
            "expiration": "Set reasonable expiration times (1-2 minutes) for rate limit data",
            "cleanup": "Transients automatically expire, no manual cleanup needed"
        },
        "performanceOptimization": {
            "rule": "Balance rate limiting with performance needs",
            "caching": "Cache successful API responses to reduce API calls",
            "batchProcessing": "Consider batching when APIs support it",
            "fallbacks": "Provide meaningful fallbacks when APIs are unavailable or rate limited"
        }
    },
    "criticalBugResolutionPatterns": {
        "description": "Comprehensive patterns for resolving critical production issues learned from duplicate images, geocoding failures, and duplicate posts",
        "duplicateImagePrevention": {
            "rule": "Implement multi-layered duplicate image detection to handle WordPress automatic file renaming",
            "primaryDetection": "Use meta-based lookup with _treb_mls_number and _treb_image_number",
            "fallbackDetection": "Check for WordPress duplicate filenames (image-1.jpg, image-2.jpg) using _wp_attached_file meta",
            "autoCleanup": "Automatically remove duplicate attachments and keep the first one",
            "metaRepair": "Ensure proper meta fields are set on recovered attachments",
            "logging": "Log all duplicate detection and cleanup operations for monitoring",
            "implementation": {
                "pattern": "First check by meta → fallback to filename pattern → cleanup duplicates → repair meta",
                "example": "get_posts with meta_query for _wp_attached_file LIKE pattern, then wp_delete_attachment for duplicates"
            }
        },
        "intelligentAddressCleaning": {
            "rule": "Preserve street name components while removing apartment designations using context-aware regex",
            "streetNamePreservation": "Never remove directional words (Upper/Lower/North/South/East/West) when part of street names",
            "apartmentDesignationRemoval": "Only remove UPPER/LOWER when followed by comma or end of string, not when followed by street type words",
            "contextAwareRegex": "Use negative lookahead to check if directional word is followed by street type (Street, Avenue, Drive, etc.)",
            "multipleVariations": "Generate multiple address cleaning variations (aggressive, conservative, basic)",
            "comprehensiveTesting": "Test with diverse real-world address patterns including condos, apartments, complex street names",
            "implementation": {
                "preservationPattern": "/\\s+(UPPER|LOWER)(?=\\s*,|\\s*$)(?!\\s+(?:Street|St|Avenue|Ave|Road|Rd|Drive|Dr|...))/i",
                "testCoverage": "Include Toronto area codes, hyphenated streets, apostrophes, multiple directional words"
            }
        },
        "robustDuplicatePostPrevention": {
            "rule": "Implement multi-layered duplicate detection with race condition protection",
            "primaryDetection": "Meta field lookup (listing_mls_number)",
            "fallbackMethods": ["Tag-based detection for race conditions", "Title search with MLS verification", "Auto-repair missing meta/tags"],
            "proactiveCleanup": "Clean up existing duplicates before creating new posts",
            "attachmentMigration": "Move attachments from duplicate to primary post before deletion",
            "immediateTagSetting": "Set MLS tags during wp_insert_post() to prevent race conditions",
            "comprehensiveLogging": "Track all duplicate detection, cleanup, and repair operations",
            "implementation": {
                "detectionOrder": "get_posts by meta → get_posts by tag → get_posts by search → cleanup duplicates",
                "raceConditionPrevention": "wp_set_post_tags immediately after wp_insert_post"
            }
        }
    },
    "comprehensiveTestingPatterns": {
        "description": "Testing patterns for ensuring robust coverage and preventing regressions",
        "zeroToleranceTestingPolicy": {
            "rule": "ABSOLUTELY ZERO test failures are acceptable - every single test must pass",
            "enforcement": "Fix ALL failures immediately, no exceptions or 'good enough' results",
            "process": ["Run php -l syntax check", "Run composer test after every change", "Investigate and resolve each failure completely"],
            "coverage": "Add tests for every bug fix to prevent future regressions"
        },
        "realWorldTestData": {
            "rule": "Use comprehensive real-world data patterns in tests",
            "addressTesting": "Include diverse Toronto area addresses: condos, apartments, complex street names, directional components",
            "edgeCases": "Test hyphenated streets, apostrophes, multiple directional words, Toronto area codes (C01, C08)",
            "apartmentPatterns": "Test APT, UNIT, BSMT, MAIN, UPPER, LOWER designations in various contexts",
            "streetNameVariations": "Test Upper/Lower/North/South/East/West in different positions within street names"
        },
        "comprehensiveAssertions": {
            "rule": "Design tests with extensive assertion coverage",
            "multipleScenarios": "Test both positive (should_contain) and negative (should_not_contain) cases",
            "detailedFailureMessages": "Include input data, expected results, and actual variations in failure messages",
            "edgeCaseValidation": "Test boundary conditions and unusual but valid data patterns"
        }
    },
    "productionIssueDebuggingPatterns": {
        "description": "Systematic approaches for diagnosing and resolving production issues",
        "issueAnalysisWorkflow": {
            "rule": "Follow systematic investigation process for production issues",
            "dataExamination": "Examine actual production data (wp post get, wp post meta list, wp post list)",
            "logAnalysis": "Review sync logs for patterns and error messages",
            "codeTracing": "Trace execution flow to identify where issues occur",
            "testReproduction": "Create specific test cases that reproduce the production issue"
        },
        "evidenceGathering": {
            "rule": "Collect comprehensive evidence before implementing fixes",
            "examples": [
                "Duplicate images: Check attachment post_parent relationships and filenames",
                "Geocoding failures: Examine address cleaning variations and API responses", 
                "Duplicate posts: Check MLS tags, meta fields, and creation timestamps"
            ],
            "toolUsage": "Use wp-cli commands to investigate database state and relationships"
        },
        "rootCauseIdentification": {
            "rule": "Identify underlying causes, not just symptoms",
            "commonPatterns": [
                "Race conditions during rapid processing",
                "Overly aggressive regex patterns",
                "Missing fallback detection methods",
                "Insufficient validation of external data"
            ],
            "preventionFocus": "Design fixes that prevent the issue class, not just the specific instance"
        }
    },
    "wordpressMediaLibraryBestPractices": {
        "description": "Advanced patterns for WordPress media library integration and duplicate prevention",
        "attachmentCreationBestPractices": {
            "rule": "Follow WordPress standards with enhanced duplicate prevention",
            "creationProcess": [
                "Download with wp_remote_get()",
                "Save with wp_upload_bits()", 
                "Create attachment with wp_insert_attachment() including correct post_parent",
                "Generate metadata with wp_generate_attachment_metadata()",
                "Update metadata with wp_update_attachment_metadata()",
                "Verify post_parent relationship and correct if needed"
            ],
            "duplicatePrevention": "Check for existing attachments by MLS number and image number before downloading",
            "orphanedAttachmentHandling": "Detect and correct post_parent=0 attachments automatically"
        },
        "attachmentMetaManagement": {
            "rule": "Use comprehensive meta fields for attachment tracking and duplicate detection",
            "requiredMeta": ["_treb_mls_number", "_treb_image_number", "_treb_source_url"],
            "fallbackDetection": "Use _wp_attached_file for filename-based duplicate detection",
            "metaRepair": "Automatically repair missing meta fields when attachments are found by alternate methods"
        }
    },
    "geocodingAndAddressProcessingPatterns": {
        "description": "Best practices for address processing and geocoding with external APIs",
        "intelligentAddressProcessing": {
            "rule": "Preserve meaningful address components while cleaning problematic elements",
            "streetNameIntelligence": "Distinguish between directional street name components and apartment designations",
            "contextAwareRegex": "Use lookahead/lookbehind patterns to understand word context",
            "multipleVariations": "Generate multiple cleaning variations for better geocoding success rates",
            "realWorldTesting": "Test with actual address patterns from target geographic area"
        },
        "geocodingReliability": {
            "rule": "Implement robust geocoding with proper error handling and fallbacks",
            "rateLimitCompliance": "Respect API rate limits (e.g., OpenStreetMap 1 req/sec) with transient tracking",
            "errorHandling": "Handle 429 responses, network errors, JSON parsing errors, empty results",
            "addressVariations": "Try multiple cleaned address variations until one succeeds",
            "caching": "Cache successful results for 7 days, failures for 1 hour only"
        }
    },
    "raceConditionPreventionPatterns": {
        "description": "Patterns for preventing race conditions in rapid processing scenarios",
        "immediateDataCommitment": {
            "rule": "Commit critical identifying data immediately during object creation",
            "postCreation": "Set MLS tags and meta fields immediately after wp_insert_post()",
            "attachmentCreation": "Set identifying meta fields immediately after wp_insert_attachment()",
            "transactionSafety": "Ensure critical data is committed before any external operations"
        },
        "multiLayeredDetection": {
            "rule": "Implement multiple detection methods to handle timing issues",
            "detectionHierarchy": "Primary method → fallback method → last resort method → auto-repair",
            "gracefulDegradation": "Each method should handle cases where previous methods failed",
            "autoRepair": "Automatically fix missing data when found by alternate detection methods"
        }
    },
    "comprehensiveLoggingPatterns": {
        "description": "Advanced logging strategies for complex operations and debugging",
        "operationalLogging": {
            "rule": "Log all major operations with sufficient context for debugging",
            "duplicateDetection": "Log detection method used, items found, cleanup actions taken",
            "addressCleaning": "Log original address, variations generated, geocoding attempts and results",
            "postProcessing": "Log creation/update decisions, duplicate cleanup, attachment operations"
        },
        "debuggingSupport": {
            "rule": "Include actionable information in log entries",
            "contextData": "Include relevant IDs, counts, URLs, and processing decisions",
            "errorDetails": "Log HTTP response codes, API error messages, and retry attempts",
            "performanceMetrics": "Log processing times, batch sizes, and success/failure rates"
        }
    },
    "testDrivenBugFixingPatterns": {
        "description": "Methodology for fixing bugs with comprehensive test coverage",
        "bugFixWorkflow": {
            "rule": "Always create tests that reproduce the bug before fixing it",
            "process": [
                "Analyze production issue with real data",
                "Create test case that reproduces the issue", 
                "Verify test fails with current code",
                "Implement fix",
                "Verify test passes",
                "Add additional edge case tests",
                "Run full test suite to ensure no regressions"
            ]
        },
        "preventionFocusedTesting": {
            "rule": "Design tests to prevent entire classes of issues, not just specific instances",
            "comprehensiveCoverage": "Test multiple variations of the same issue pattern",
            "edgeCaseExploration": "Include boundary conditions and unusual but valid scenarios",
            "realWorldData": "Use actual production data patterns in test cases"
        }
    },
    "conditionalPublishingPatterns": {
        "description": "Best practices for conditional post publishing based on content availability (v1.6.3+)",
        "imageBasedPublishing": {
            "rule": "Never publish listing posts without images to prevent poor user experience",
            "implementation": "Create posts as draft initially, publish only after successful image download",
            "benefits": [
                "Prevents imageless listings from appearing on site",
                "Automatically resolves when images become available",
                "Provides clear draft queue for manual review"
            ]
        },
        "creationFlow": {
            "rule": "All new posts start as draft, conditionally promoted to published",
            "process": [
                "1. Create post with post_status='draft'",
                "2. Store meta data and tags immediately",
                "3. Process listing images",
                "4. If images_downloaded > 0, update to post_status='publish'",
                "5. If no images, remain as draft with external references stored"
            ],
            "logging": "Log final status decision with image stats for debugging"
        },
        "updateFlow": {
            "rule": "Updates retry failed images and can auto-publish drafts",
            "process": [
                "1. Get current post status",
                "2. Retry any stored external image references",
                "3. Process new images from API",
                "4. Determine new status based on image availability",
                "5. If was draft + now has images = publish",
                "6. If was published + lost all images = draft (edge case)"
            ],
            "benefits": "Automatic resolution of temporary image failures"
        },
        "retryMechanism": {
            "rule": "Store failed image URLs for future retry attempts",
            "storage": "Use _treb_external_images post meta with URL, MLS, image number, attempts, timestamp",
            "retryTriggers": [
                "Automatic: During post updates via normal sync",
                "Manual: WP-CLI command 'wp shift8-treb retry-images'",
                "Scheduled: Could implement dedicated retry cron (future enhancement)"
            ],
            "cleanup": "Remove external references when images successfully download"
        },
        "wpcliIntegration": {
            "rule": "Provide manual retry command for admin control",
            "command": "wp shift8-treb retry-images [--limit=N] [--status=draft|publish|any] [--dry-run]",
            "features": [
                "Process posts with failed images",
                "Show progress and statistics",
                "Auto-publish drafts when images succeed",
                "Support filtering and limits"
            ],
            "useCase": "Admin sees drafts piling up, manually triggers retry to resolve"
        },
        "testingRequirements": {
            "rule": "Comprehensive test coverage for all status transitions",
            "tests": [
                "Post created as draft when no images",
                "Post published when images succeed",
                "Draft auto-published when images become available",
                "Update retries external images",
                "Retry method handles various failure scenarios"
            ],
            "mocking": "Ensure test mocks don't break is_wp_error() and other WordPress functions"
        },
        "userCommunication": {
            "rule": "Clearly document this behavior for end users",
            "documentation": [
                "Explain why some listings appear as drafts",
                "Document retry-images CLI command",
                "Provide troubleshooting steps for persistent failures",
                "Set expectations about automatic resolution"
            ]
        }
    },
    "apiResponseComparisonAntiPattern": {
        "description": "CRITICAL LESSON: Never compare API response to WordPress posts for cleanup decisions",
        "learnedDate": "2025-10-30",
        "problem": {
            "rule": "NEVER compare what's in API response vs what's in WordPress to determine what to delete",
            "reasoning": "API responses are LIMITED and FILTERED - they don't contain ALL listings",
            "examples": [
                "API query limited to 100-1000 listings (not entire MLS database)",
                "API filtered by listing_age_days (e.g., only last 30 days)",
                "API filtered by ModificationTimestamp (incremental sync)",
                "API filtered by member_id (only specific agents)",
                "API filtered by transaction_type (sale vs lease)"
            ],
            "consequences": "Comparing API response to WordPress posts would DELETE valid old listings that simply weren't in that specific limited query"
        },
        "correctApproach": {
            "rule": "Query API specifically for terminated/cancelled listings, then check if those exist in WordPress",
            "implementation": [
                "Query API with: StandardStatus eq 'Cancelled' or 'Expired' or 'Withdrawn' or 'Terminated'",
                "Limit to recent modifications (last 30 days) for performance",
                "Get up to 200 terminated listings",
                "For each terminated MLS number, check if it exists as WordPress post",
                "Only remove posts that ARE in the terminated list"
            ],
            "benefits": [
                "Only 1 API query instead of 200 individual queries",
                "Removes confirmed terminated listings",
                "Never accidentally deletes valid active listings",
                "Performance efficient (weekly vs daily)"
            ]
        },
        "preventionChecklist": [
            "✓ Never use in_array($mls, $api_response_mls_numbers) to determine deletions",
            "✓ Never assume API response contains ALL listings",
            "✓ Always query API for SPECIFIC statuses you want to act on",
            "✓ Always consider API query limits and filters",
            "✓ Test logic with: 'What if API only returns 50 of 500 total listings?'"
        ]
    },
    "terminatedListingsCleanupPatterns": {
        "description": "Best practices for handling terminated/cancelled/expired real estate listings",
        "learnedDate": "2025-10-30",
        "preventionAtApiLevel": {
            "rule": "Use StandardStatus filter to prevent importing terminated listings",
            "implementation": "StandardStatus eq 'Active' or 'Pending' or 'Closed' (NOT Cancelled/Expired/Withdrawn/Terminated)",
            "additionalSafety": "ContractStatus ne 'Unavailable' as secondary filter",
            "benefits": "Prevents terminated listings from ever being imported"
        },
        "weeklyCleanupJob": {
            "rule": "Separate weekly cron job to remove terminated listings that slip through",
            "frequency": "Weekly (not daily) for performance optimization",
            "apiQuery": "Query for terminated statuses modified in last 30 days (up to 200)",
            "wordpressQuery": "For each terminated MLS, check if exists in WordPress and remove",
            "performance": "1 API query/week vs 200 queries/day (1400x reduction)",
            "schedule": "Use WordPress cron 'weekly' schedule independently from main sync"
        },
        "implementation": {
            "apiFilterAtSync": "Prevent import at source with StandardStatus filter",
            "separateCleanupJob": "Independent weekly job queries API for terminated listings specifically",
            "queryOptimization": "Limit to last 30 days, up to 200 results, single API call",
            "wordpressCleanup": "Loop through terminated MLS numbers, check WordPress, remove if exists"
        }
    },
    "transactionTypeDualListingsPattern": {
        "description": "Handle real-world scenario where same property listed for both sale and lease",
        "learnedDate": "2025-10-30",
        "realWorldScenario": {
            "problem": "Same address appears twice: once as 'For Sale' ($500k) and once as 'For Lease' ($2500/mo)",
            "mlsNumbers": "Different MLS numbers (e.g., W12364279 for sale, W12364198 for lease)",
            "cause": "Agent lists property for both purchase and rental simultaneously"
        },
        "solution": {
            "titleDifferentiation": "Prefix post titles with transaction type",
            "examples": [
                "For Sale: 123 Main Street, Toronto, ON",
                "For Lease: 123 Main Street, Toronto, ON",
                "For Sale or Lease: 123 Main Street, Toronto, ON"
            ],
            "implementation": "Check listing['TransactionType'] and prepend to title",
            "userBenefit": "Users can clearly see if same property is for sale vs lease"
        },
        "optionalFiltering": {
            "rule": "Allow admins to filter by transaction type if they only want sale or lease listings",
            "setting": "transaction_type_filter (For Sale, For Lease, For Sale or Lease, or empty for all)",
            "apiImplementation": "Add TransactionType eq '[value]' to API $filter parameter"
        },
        "keyInsight": "Dual listings are VALID and should be imported as separate posts with differentiated titles"
    },
    "cronJobPerformancePatterns": {
        "description": "Performance considerations for WordPress cron jobs in real estate plugins",
        "learnedDate": "2025-10-30",
        "performanceAnalysis": {
            "rule": "Always analyze API call volume and execution time before setting cron frequency",
            "badExample": {
                "frequency": "Daily cleanup making 200 individual API calls",
                "apiCalls": "200 calls/day = 6000 calls/month",
                "executionTime": "3-5 minutes per execution",
                "risk": "API rate limiting, server load, quota exhaustion"
            },
            "goodExample": {
                "frequency": "Weekly cleanup making 1 API query",
                "apiCalls": "1 call/week = 4 calls/month",
                "executionTime": "5-10 seconds per execution",
                "optimization": "1500x reduction in API calls"
            }
        },
        "bestPractices": {
            "apiQueryDesign": "Design queries to get needed data in single call, not loop of individual calls",
            "batchProcessing": "Query for multiple items at once (e.g., 200 terminated listings) vs individual lookups",
            "frequencyOptimization": "Weekly is sufficient for cleanup - terminated listings don't need immediate removal",
            "loadDistribution": "Main sync + cleanup jobs = 2 cron jobs with different schedules",
            "performanceMetrics": "Document API calls per execution and frequency for future optimization"
        },
        "evaluationQuestions": [
            "How many API calls does this cron job make per execution?",
            "What's the execution time?",
            "How often does it need to run? (Daily vs weekly vs hourly)",
            "Can we batch the operations instead of individual calls?",
            "What's the total monthly API usage? (calls * frequency)",
            "Are there API rate limits we might hit?",
            "Is there a more efficient query structure?"
        ]
    }
}
